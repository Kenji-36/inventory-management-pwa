# ブログ記事執筆支援Webアプリケーション システム設計書

## 1. ドキュメント情報

**文書バージョン**: 1.0  
**作成日**: 2025年12月1日  
**最終更新日**: 2025年12月1日  
**関連ドキュメント**: 機能要件書.md、画面設計書.md

---

## 2. システム概要

### 2.1 システムアーキテクチャ

```
┌─────────────────────────────────────────────────────────┐
│                     ユーザー                             │
└─────────────────────────────────────────────────────────┘
                          │
                          │ HTTPS
                          ▼
┌─────────────────────────────────────────────────────────┐
│                  フロントエンド                          │
│  ┌─────────────────────────────────────────────────┐   │
│  │           React / Next.js (SPA)                 │   │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐     │   │
│  │  │  UI      │  │  State   │  │  Router  │     │   │
│  │  │Components│  │Management│  │          │     │   │
│  │  └──────────┘  └──────────┘  └──────────┘     │   │
│  └─────────────────────────────────────────────────┘   │
│                          │                              │
│                          │ Local Storage                │
│                          ▼                              │
│  ┌─────────────────────────────────────────────────┐   │
│  │         ブラウザストレージ（一時保存）           │   │
│  └─────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
                          │
                          │ REST API / WebSocket
                          ▼
┌─────────────────────────────────────────────────────────┐
│                  バックエンド                            │
│  ┌─────────────────────────────────────────────────┐   │
│  │         Node.js / Express (API Server)          │   │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐     │   │
│  │  │  API     │  │  Business│  │  AI      │     │   │
│  │  │  Routes  │  │  Logic   │  │  Service │     │   │
│  │  └──────────┘  └──────────┘  └──────────┘     │   │
│  └─────────────────────────────────────────────────┘   │
│                          │                              │
│                          │                              │
│  ┌─────────────────────────────────────────────────┐   │
│  │         ミドルウェア・ユーティリティ             │   │
│  │  - エラーハンドリング                            │   │
│  │  - レート制限                                    │   │
│  │  - ロギング                                      │   │
│  └─────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
                          │
                          │ API Call
                          ▼
┌─────────────────────────────────────────────────────────┐
│                  外部サービス                            │
│  ┌──────────────────┐      ┌──────────────────┐        │
│  │  OpenAI API      │  or  │  Anthropic API   │        │
│  │  (ChatGPT)       │      │  (Claude)        │        │
│  └──────────────────┘      └──────────────────┘        │
└─────────────────────────────────────────────────────────┘

                    [将来の拡張]
                          │
                          ▼
┌─────────────────────────────────────────────────────────┐
│                  データベース                            │
│  ┌──────────────────┐      ┌──────────────────┐        │
│  │  PostgreSQL      │      │  Redis           │        │
│  │  (永続化データ)   │      │  (キャッシュ)     │        │
│  └──────────────────┘      └──────────────────┘        │
└─────────────────────────────────────────────────────────┘
```

### 2.2 アーキテクチャパターン

**MVP段階**: クライアントサイド中心のアーキテクチャ
- **フロントエンド**: React SPA（Single Page Application）
- **バックエンド**: 薄いAPIレイヤー（AI APIへのプロキシ）
- **データ保存**: ローカルストレージ（ブラウザ）

**将来**: フルスタックアーキテクチャ
- **フロントエンド**: Next.js（SSR/SSG対応）
- **バックエンド**: 本格的なビジネスロジック
- **データベース**: PostgreSQL（ユーザーデータ、記事データ）
- **キャッシュ**: Redis（セッション、API結果）

---

## 3. 技術スタック

### 3.1 フロントエンド

#### 3.1.1 コアフレームワーク
```
React 18.x + TypeScript
├── Next.js 14.x (推奨) or Vite
├── TypeScript 5.x
└── Node.js 20.x LTS
```

**選定理由**:
- React: 豊富なエコシステム、コンポーネント再利用性
- TypeScript: 型安全性、開発効率向上
- Next.js: SSR/SSG対応、API Routes、将来の拡張性

#### 3.1.2 状態管理
```
選択肢1: Zustand (推奨 - シンプル)
選択肢2: Redux Toolkit (大規模化を見越す場合)
選択肢3: React Context + useReducer (最小構成)
```

**推奨**: Zustand
- 軽量でシンプル
- Boilerplateが少ない
- TypeScript対応が優れている

#### 3.1.3 UIライブラリ・スタイリング
```
Tailwind CSS 3.x
├── HeadlessUI (アクセシブルなコンポーネント)
├── Radix UI (代替案)
└── Framer Motion (アニメーション)
```

**選定理由**:
- Tailwind CSS: 高速開発、カスタマイズ性
- HeadlessUI: アクセシビリティ対応済み
- Framer Motion: 滑らかなアニメーション

#### 3.1.4 フォーム管理
```
React Hook Form 7.x
└── Zod (バリデーション)
```

#### 3.1.5 Markdownエディタ・レンダラー
```
react-markdown (レンダリング)
├── remark-gfm (GitHub Flavored Markdown)
└── rehype-highlight (シンタックスハイライト)

または

@uiw/react-md-editor (編集+プレビュー統合)
```

#### 3.1.6 ドラッグ&ドロップ
```
@dnd-kit/core (推奨)
または
react-beautiful-dnd
```

#### 3.1.7 HTTP通信
```
Axios 1.x
または
TanStack Query (React Query) 5.x (推奨)
```

**推奨**: TanStack Query
- キャッシング機能
- 自動リトライ
- ローディング・エラー状態管理

#### 3.1.8 ストレージ
```
localforage (推奨)
または
localStorage API (標準)
```

### 3.2 バックエンド

#### 3.2.1 サーバーフレームワーク
```
Node.js 20.x LTS + TypeScript
└── Express.js 4.x
    または
    Next.js API Routes (推奨 - フロントエンドと統合)
```

**推奨**: Next.js API Routes（MVP段階）
- フロントエンドと同じリポジトリ
- デプロイが簡単
- サーバーレス対応

#### 3.2.2 AI API クライアント
```
OpenAI SDK (openai 4.x)
または
Anthropic SDK (@anthropic-ai/sdk)
```

#### 3.2.3 環境変数管理
```
dotenv
└── .env.local (Next.js標準)
```

#### 3.2.4 バリデーション
```
Zod (フロントエンドと共通)
```

### 3.3 開発ツール

#### 3.3.1 パッケージマネージャー
```
pnpm (推奨 - 高速、ディスク効率)
または
npm / yarn
```

#### 3.3.2 リンター・フォーマッター
```
ESLint 8.x
├── @typescript-eslint
├── eslint-config-next (Next.js使用時)
└── eslint-plugin-react-hooks

Prettier 3.x
└── prettier-plugin-tailwindcss
```

#### 3.3.3 Git Hooks
```
Husky 8.x
└── lint-staged
```

#### 3.3.4 テスティング
```
Vitest (推奨 - 高速)
├── @testing-library/react
├── @testing-library/jest-dom
└── @testing-library/user-event

Playwright (E2Eテスト)
```

### 3.4 インフラ・デプロイ

#### 3.4.1 ホスティング（MVP）
```
選択肢1: Vercel (推奨 - Next.js最適化)
選択肢2: Netlify
選択肢3: Cloudflare Pages
```

**推奨**: Vercel
- Next.jsとの統合が最高
- 自動デプロイ
- サーバーレス関数対応
- 無料枠が充実

#### 3.4.2 CI/CD
```
GitHub Actions (推奨)
├── ビルド・テスト自動化
├── リント・型チェック
└── 自動デプロイ
```

#### 3.4.3 監視・ログ（将来）
```
Sentry (エラートラッキング)
Vercel Analytics (パフォーマンス監視)
```

### 3.5 外部API

#### 3.5.1 AI API選定

**選択肢1: OpenAI API (ChatGPT)**
```
モデル: gpt-4-turbo または gpt-3.5-turbo
料金: 従量課金
- gpt-4-turbo: 高品質、高コスト
- gpt-3.5-turbo: バランス型
```

**選択肢2: Anthropic API (Claude)**
```
モデル: claude-3-opus または claude-3-sonnet
料金: 従量課金
- claude-3-opus: 最高品質
- claude-3-sonnet: バランス型
```

**推奨**: 両方対応（切り替え可能に設計）
- 環境変数で選択
- コスト・品質で使い分け

---

## 4. データ構造設計

### 4.1 ローカルストレージスキーマ（MVP）

#### 4.1.1 プロジェクトデータ構造

```typescript
interface BlogProject {
  id: string;                    // UUID
  version: string;               // データバージョン "1.0"
  createdAt: string;             // ISO 8601形式
  updatedAt: string;             // ISO 8601形式
  currentStep: number;           // 1-5 (現在のステップ)
  
  // ステップ1: テーマ
  theme: {
    text: string;                // テーマ本文
  };
  
  // ステップ2: 見出し
  headlines: {
    candidates: Headline[];      // 生成された候補
    selected: Headline | null;   // 選択された見出し
    generationCount: number;     // 再生成回数
  };
  
  // ステップ3: 目次
  outline: {
    items: OutlineItem[];        // 目次項目
    generationCount: number;     // 再生成回数
  };
  
  // ステップ4: 本文
  content: {
    sections: ContentSection[];  // セクションごとの本文
    generationMode: 'sequential' | 'batch'; // 生成モード
  };
  
  // メタデータ
  metadata: {
    totalGenerationTime: number; // 合計生成時間（秒）
    aiModel: string;             // 使用したAIモデル
    wordCount: number;           // 総文字数
  };
}

interface Headline {
  id: string;
  text: string;                  // 見出しテキスト
  description: string;           // 説明文
  generatedAt: string;
}

interface OutlineItem {
  id: string;
  level: 2 | 3;                  // H2 or H3
  text: string;                  // 見出しテキスト
  order: number;                 // 表示順序
  parentId: string | null;       // 親のID（H3の場合）
}

interface ContentSection {
  id: string;
  outlineItemId: string;         // 対応する目次項目のID
  text: string;                  // 本文テキスト
  status: 'pending' | 'generating' | 'completed' | 'error';
  generatedAt: string | null;
  generationCount: number;       // 再生成回数
  wordCount: number;             // 文字数
}
```

#### 4.1.2 ストレージキー

```typescript
const STORAGE_KEYS = {
  CURRENT_PROJECT: 'blog-generator:current-project',
  SETTINGS: 'blog-generator:settings',
  GENERATION_HISTORY: 'blog-generator:history', // 将来用
} as const;
```

#### 4.1.3 設定データ

```typescript
interface AppSettings {
  aiProvider: 'openai' | 'anthropic';
  model: string;                 // 使用モデル
  temperature: number;           // 0.0 - 1.0
  maxTokens: number;             // 最大トークン数
  language: 'ja' | 'en';         // UI言語
  theme: 'light' | 'dark';       // テーマ（将来）
}
```

### 4.2 データベーススキーマ（将来実装）

#### 4.2.1 ER図

```
┌─────────────┐
│   users     │
├─────────────┤
│ id (PK)     │
│ email       │
│ name        │
│ created_at  │
│ updated_at  │
└─────────────┘
       │
       │ 1:N
       ▼
┌─────────────┐
│  projects   │
├─────────────┤
│ id (PK)     │
│ user_id (FK)│
│ title       │
│ status      │
│ data (JSON) │◄── BlogProject構造をJSON保存
│ created_at  │
│ updated_at  │
└─────────────┘
       │
       │ 1:N
       ▼
┌─────────────┐
│ generations │
├─────────────┤
│ id (PK)     │
│ project_id  │
│ type        │   ← 'headline' | 'outline' | 'content'
│ input       │
│ output      │
│ model       │
│ tokens      │
│ cost        │
│ created_at  │
└─────────────┘
```

#### 4.2.2 テーブル定義（PostgreSQL）

```sql
-- ユーザーテーブル
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email VARCHAR(255) UNIQUE NOT NULL,
  name VARCHAR(255),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- プロジェクトテーブル
CREATE TABLE projects (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  title VARCHAR(500) NOT NULL,
  status VARCHAR(50) DEFAULT 'draft', -- draft, completed, archived
  data JSONB NOT NULL, -- BlogProject構造
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 生成履歴テーブル（コスト管理・分析用）
CREATE TABLE generations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
  type VARCHAR(50) NOT NULL, -- headline, outline, content
  input TEXT NOT NULL,
  output TEXT NOT NULL,
  model VARCHAR(100) NOT NULL,
  tokens INTEGER,
  cost DECIMAL(10, 6),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- インデックス
CREATE INDEX idx_projects_user_id ON projects(user_id);
CREATE INDEX idx_projects_status ON projects(status);
CREATE INDEX idx_generations_project_id ON generations(project_id);
CREATE INDEX idx_generations_created_at ON generations(created_at);
```

---

## 5. API設計

### 5.1 エンドポイント一覧（MVP）

#### 5.1.1 見出し生成

```
POST /api/generate/headline
```

**リクエスト**:
```json
{
  "theme": "初心者向けのSEO対策の基本",
  "count": 5,
  "language": "ja"
}
```

**レスポンス**:
```json
{
  "success": true,
  "data": {
    "headlines": [
      {
        "id": "uuid-1",
        "text": "初心者でも分かる！SEO対策の基本ステップ",
        "description": "この見出しでは、SEOの基礎から実践まで解説します"
      },
      // ... 他の候補
    ]
  },
  "metadata": {
    "model": "gpt-4-turbo",
    "generationTime": 3.2
  }
}
```

**エラーレスポンス**:
```json
{
  "success": false,
  "error": {
    "code": "RATE_LIMIT_EXCEEDED",
    "message": "リクエスト制限に達しました。しばらく待ってから再試行してください。"
  }
}
```

#### 5.1.2 目次生成

```
POST /api/generate/outline
```

**リクエスト**:
```json
{
  "headline": "初心者でも分かる！SEO対策の基本ステップ",
  "theme": "初心者向けのSEO対策の基本",
  "language": "ja"
}
```

**レスポンス**:
```json
{
  "success": true,
  "data": {
    "outline": [
      {
        "id": "uuid-1",
        "level": 2,
        "text": "SEOとは？",
        "order": 1,
        "parentId": null
      },
      {
        "id": "uuid-2",
        "level": 3,
        "text": "SEOの定義",
        "order": 2,
        "parentId": "uuid-1"
      },
      // ... 他の項目
    ]
  }
}
```

#### 5.1.3 本文生成

```
POST /api/generate/content
```

**リクエスト**:
```json
{
  "outlineItem": {
    "id": "uuid-1",
    "level": 2,
    "text": "SEOとは？"
  },
  "context": {
    "headline": "初心者でも分かる！SEO対策の基本ステップ",
    "previousSections": ["..."], // 前のセクションの内容
    "nextSections": ["..."]      // 次のセクションの見出し
  },
  "options": {
    "targetWordCount": 500,
    "tone": "casual"
  }
}
```

**レスポンス（ストリーミング）**:
```
Content-Type: text/event-stream

data: {"type": "start", "sectionId": "uuid-1"}
data: {"type": "chunk", "text": "SEO（Search Engine Optimization）とは"}
data: {"type": "chunk", "text": "、検索エンジン最適化のことを指します。"}
data: {"type": "complete", "wordCount": 450}
```

**レスポンス（非ストリーミング）**:
```json
{
  "success": true,
  "data": {
    "sectionId": "uuid-1",
    "text": "SEO（Search Engine Optimization）とは、検索エンジン最適化のことを指します。...",
    "wordCount": 450
  }
}
```

#### 5.1.4 バッチ生成

```
POST /api/generate/content/batch
```

**リクエスト**:
```json
{
  "outlineItems": [
    {"id": "uuid-1", "level": 2, "text": "SEOとは？"},
    {"id": "uuid-2", "level": 2, "text": "キーワード選定"}
  ],
  "context": {
    "headline": "...",
    "theme": "..."
  }
}
```

**レスポンス**:
```json
{
  "success": true,
  "data": {
    "sections": [
      {
        "sectionId": "uuid-1",
        "text": "...",
        "wordCount": 450
      },
      {
        "sectionId": "uuid-2",
        "text": "...",
        "wordCount": 520
      }
    ]
  }
}
```

### 5.2 エラーコード定義

| コード | 説明 | HTTPステータス |
|--------|------|----------------|
| `INVALID_INPUT` | 入力データが不正 | 400 |
| `RATE_LIMIT_EXCEEDED` | レート制限超過 | 429 |
| `AI_SERVICE_ERROR` | AI API エラー | 502 |
| `TIMEOUT` | タイムアウト | 504 |
| `INTERNAL_ERROR` | サーバー内部エラー | 500 |

### 5.3 レート制限

**MVP段階**:
- IP単位: 100リクエスト/時間
- セッション単位: 50リクエスト/時間

**将来（ユーザー認証後）**:
- 無料プラン: 10記事/月
- 有料プラン: 100記事/月

---

## 6. AI統合設計

### 6.1 プロンプト設計

#### 6.1.1 見出し生成プロンプト

```typescript
const HEADLINE_PROMPT = `
あなたはプロのブログライターです。
以下のテーマに基づいて、魅力的なブログ記事の見出しを${count}個提案してください。

テーマ: ${theme}

要件:
- 読者の興味を引く見出し
- SEOを意識したキーワード配置
- 30文字以内
- 各見出しに1-2行の簡単な説明を付ける

出力形式（JSON）:
{
  "headlines": [
    {
      "text": "見出しテキスト",
      "description": "この見出しの説明"
    }
  ]
}
`;
```

#### 6.1.2 目次生成プロンプト

```typescript
const OUTLINE_PROMPT = `
あなたはプロのブログライターです。
以下の見出しに基づいて、詳細な記事の目次を作成してください。

見出し: ${headline}
テーマ: ${theme}

要件:
- 大見出し（H2）を3-5個
- 各大見出しに中見出し（H3）を2-4個
- 論理的な流れ
- 読者が理解しやすい構成

出力形式（JSON）:
{
  "outline": [
    {
      "level": 2,
      "text": "大見出し1",
      "children": [
        {"level": 3, "text": "中見出し1-1"},
        {"level": 3, "text": "中見出し1-2"}
      ]
    }
  ]
}
`;
```

#### 6.1.3 本文生成プロンプト

```typescript
const CONTENT_PROMPT = `
あなたはプロのブログライターです。
以下のセクションの本文を執筆してください。

記事見出し: ${headline}
セクション: ${sectionTitle}
前のセクション: ${previousContext}
次のセクション: ${nextContext}

要件:
- 目標文字数: ${targetWordCount}文字程度
- 読みやすい文章
- 具体例を含める
- 前後のセクションとの一貫性を保つ

出力形式: Markdown形式で本文のみ
`;
```

### 6.2 トークン管理

#### 6.2.1 推定トークン数

| 処理 | 入力トークン | 出力トークン | 合計 |
|------|-------------|-------------|------|
| 見出し生成 | ~200 | ~500 | ~700 |
| 目次生成 | ~300 | ~800 | ~1,100 |
| 本文生成（1セクション） | ~500 | ~1,500 | ~2,000 |
| 記事全体（5セクション） | - | - | ~11,000 |

#### 6.2.2 コスト試算（OpenAI gpt-4-turbo）

```
料金（2025年12月時点の想定）:
- 入力: $0.01 / 1K tokens
- 出力: $0.03 / 1K tokens

1記事あたりのコスト:
- 入力: (200 + 300 + 500*5) * 0.01 / 1000 = $0.03
- 出力: (500 + 800 + 1500*5) * 0.03 / 1000 = $0.26
- 合計: 約$0.29 / 記事
```

### 6.3 エラーハンドリング・リトライ戦略

```typescript
const AI_CONFIG = {
  maxRetries: 3,
  retryDelay: 1000, // ms
  timeout: 30000,   // 30秒
  
  retryConditions: [
    'RATE_LIMIT_EXCEEDED',
    'TIMEOUT',
    'NETWORK_ERROR'
  ],
  
  exponentialBackoff: true,
  backoffMultiplier: 2
};
```

---

## 7. セキュリティ設計

### 7.1 APIキー管理

```
環境変数での管理:
.env.local (ローカル開発)
├── OPENAI_API_KEY=sk-...
├── ANTHROPIC_API_KEY=sk-ant-...
└── NEXT_PUBLIC_APP_URL=http://localhost:3000

本番環境:
- Vercel Environment Variables
- GitHub Secrets（CI/CD用）
```

**重要**: APIキーは絶対にクライアントに露出しない
- Next.js API Routesでプロキシ
- サーバーサイドでのみ使用

### 7.2 入力サニタイゼーション

```typescript
// XSS対策
import DOMPurify from 'dompurify';

function sanitizeInput(input: string): string {
  return DOMPurify.sanitize(input, {
    ALLOWED_TAGS: [], // タグを許可しない
    ALLOWED_ATTR: []
  });
}

// 文字数制限
const MAX_THEME_LENGTH = 500;
const MAX_HEADLINE_LENGTH = 100;
const MAX_OUTLINE_ITEMS = 20;
```

### 7.3 レート制限実装

```typescript
// Next.js API Routesでの実装例
import rateLimit from 'express-rate-limit';

const limiter = rateLimit({
  windowMs: 60 * 60 * 1000, // 1時間
  max: 100, // 最大100リクエスト
  message: 'リクエスト制限に達しました'
});
```

### 7.4 CORS設定

```typescript
// Next.js設定
const corsOptions = {
  origin: process.env.NEXT_PUBLIC_APP_URL,
  methods: ['GET', 'POST'],
  credentials: true
};
```

---

## 8. パフォーマンス最適化

### 8.1 フロントエンド最適化

#### 8.1.1 コード分割

```typescript
// 動的インポート
const MarkdownEditor = dynamic(
  () => import('@/components/MarkdownEditor'),
  { ssr: false, loading: () => <LoadingSpinner /> }
);
```

#### 8.1.2 メモ化

```typescript
// React.memo でコンポーネントメモ化
export const OutlineItem = React.memo(({ item }) => {
  // ...
});

// useMemo でデータメモ化
const sortedOutline = useMemo(
  () => outline.sort((a, b) => a.order - b.order),
  [outline]
);

// useCallback で関数メモ化
const handleGenerate = useCallback(() => {
  // ...
}, [dependencies]);
```

#### 8.1.3 仮想化（長いリスト）

```typescript
import { useVirtualizer } from '@tanstack/react-virtual';

// 目次が多い場合の仮想スクロール
```

### 8.2 バックエンド最適化

#### 8.2.1 ストリーミングレスポンス

```typescript
// Server-Sent Events (SSE) でストリーミング
export async function POST(req: Request) {
  const stream = new ReadableStream({
    async start(controller) {
      const aiStream = await openai.chat.completions.create({
        model: 'gpt-4-turbo',
        messages: [...],
        stream: true
      });
      
      for await (const chunk of aiStream) {
        const text = chunk.choices[0]?.delta?.content || '';
        controller.enqueue(`data: ${JSON.stringify({ text })}\n\n`);
      }
      
      controller.close();
    }
  });
  
  return new Response(stream, {
    headers: {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive'
    }
  });
}
```

#### 8.2.2 キャッシング戦略（将来）

```typescript
// Redis でのキャッシング
const cacheKey = `outline:${hash(headline)}`;
const cached = await redis.get(cacheKey);

if (cached) {
  return JSON.parse(cached);
}

const result = await generateOutline(headline);
await redis.setex(cacheKey, 3600, JSON.stringify(result)); // 1時間
return result;
```

### 8.3 ローカルストレージ最適化

```typescript
// 圧縮してストレージ容量を節約
import LZString from 'lz-string';

function saveProject(project: BlogProject) {
  const compressed = LZString.compress(JSON.stringify(project));
  localStorage.setItem(STORAGE_KEYS.CURRENT_PROJECT, compressed);
}

function loadProject(): BlogProject | null {
  const compressed = localStorage.getItem(STORAGE_KEYS.CURRENT_PROJECT);
  if (!compressed) return null;
  
  const decompressed = LZString.decompress(compressed);
  return JSON.parse(decompressed);
}
```

---

## 9. エラーハンドリング・ロギング

### 9.1 エラー分類

```typescript
class AppError extends Error {
  constructor(
    public code: string,
    public message: string,
    public statusCode: number,
    public isOperational: boolean = true
  ) {
    super(message);
  }
}

// 具体的なエラークラス
class ValidationError extends AppError {
  constructor(message: string) {
    super('VALIDATION_ERROR', message, 400);
  }
}

class AIServiceError extends AppError {
  constructor(message: string) {
    super('AI_SERVICE_ERROR', message, 502);
  }
}

class RateLimitError extends AppError {
  constructor(message: string) {
    super('RATE_LIMIT_EXCEEDED', message, 429);
  }
}
```

### 9.2 グローバルエラーハンドラー

```typescript
// Next.js API Routes
export function errorHandler(
  error: Error,
  req: NextRequest,
  res: NextResponse
) {
  if (error instanceof AppError) {
    return NextResponse.json(
      {
        success: false,
        error: {
          code: error.code,
          message: error.message
        }
      },
      { status: error.statusCode }
    );
  }
  
  // 予期しないエラー
  console.error('Unexpected error:', error);
  return NextResponse.json(
    {
      success: false,
      error: {
        code: 'INTERNAL_ERROR',
        message: 'サーバーエラーが発生しました'
      }
    },
    { status: 500 }
  );
}
```

### 9.3 ロギング戦略

```typescript
// 構造化ログ
interface LogEntry {
  timestamp: string;
  level: 'info' | 'warn' | 'error';
  message: string;
  context?: Record<string, any>;
  error?: Error;
}

class Logger {
  info(message: string, context?: Record<string, any>) {
    console.log(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'info',
      message,
      context
    }));
  }
  
  error(message: string, error: Error, context?: Record<string, any>) {
    console.error(JSON.stringify({
      timestamp: new Date().toISOString(),
      level: 'error',
      message,
      error: {
        name: error.name,
        message: error.message,
        stack: error.stack
      },
      context
    }));
  }
}

export const logger = new Logger();
```

---

## 10. テスト戦略

### 10.1 テストピラミッド

```
        ┌─────────────┐
        │  E2E Tests  │  ← 少数（主要フロー）
        │   (10%)     │
        ├─────────────┤
        │Integration  │  ← 中程度（API、状態管理）
        │   (30%)     │
        ├─────────────┤
        │ Unit Tests  │  ← 多数（関数、コンポーネント）
        │   (60%)     │
        └─────────────┘
```

### 10.2 ユニットテスト

```typescript
// コンポーネントテスト例
import { render, screen, fireEvent } from '@testing-library/react';
import { ThemeInput } from '@/components/ThemeInput';

describe('ThemeInput', () => {
  it('入力が500文字を超えるとエラーを表示', () => {
    render(<ThemeInput />);
    const textarea = screen.getByRole('textbox');
    
    fireEvent.change(textarea, {
      target: { value: 'a'.repeat(501) }
    });
    
    expect(screen.getByText(/500文字以内/)).toBeInTheDocument();
  });
});

// ユーティリティ関数テスト例
import { sanitizeInput } from '@/utils/sanitize';

describe('sanitizeInput', () => {
  it('HTMLタグを除去する', () => {
    const input = '<script>alert("xss")</script>Hello';
    const result = sanitizeInput(input);
    expect(result).toBe('Hello');
  });
});
```

### 10.3 統合テスト

```typescript
// API統合テスト例
import { POST } from '@/app/api/generate/headline/route';

describe('POST /api/generate/headline', () => {
  it('正常に見出しを生成する', async () => {
    const request = new Request('http://localhost:3000/api/generate/headline', {
      method: 'POST',
      body: JSON.stringify({
        theme: 'テストテーマ',
        count: 3
      })
    });
    
    const response = await POST(request);
    const data = await response.json();
    
    expect(data.success).toBe(true);
    expect(data.data.headlines).toHaveLength(3);
  });
});
```

### 10.4 E2Eテスト

```typescript
// Playwright E2Eテスト例
import { test, expect } from '@playwright/test';

test('記事作成フロー全体', async ({ page }) => {
  // テーマ入力
  await page.goto('/');
  await page.fill('textarea', 'SEO対策の基本');
  await page.click('button:has-text("見出しを生成")');
  
  // 見出し選択
  await expect(page.locator('.headline-card')).toHaveCount(5);
  await page.click('.headline-card:first-child');
  await page.click('button:has-text("目次を生成")');
  
  // 目次確認
  await expect(page.locator('.outline-item')).toHaveCount.greaterThan(3);
  await page.click('button:has-text("本文を生成")');
  
  // 本文生成
  await page.click('button:has-text("生成開始")');
  await expect(page.locator('.content-section')).toHaveCount.greaterThan(0);
  
  // エクスポート
  await page.click('button:has-text("プレビュー")');
  const downloadPromise = page.waitForEvent('download');
  await page.click('button:has-text("Markdown")');
  const download = await downloadPromise;
  expect(download.suggestedFilename()).toContain('.md');
});
```

---

## 11. デプロイ・CI/CD

### 11.1 環境構成

```
開発環境 (Development)
├── ローカル開発
└── ホットリロード、デバッグモード

ステージング環境 (Staging)
├── Vercel Preview Deployment
└── プルリクエストごとに自動デプロイ

本番環境 (Production)
├── Vercel Production
└── mainブランチへのマージで自動デプロイ
```

### 11.2 GitHub Actions ワークフロー

```yaml
# .github/workflows/ci.yml
name: CI

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'
      
      - name: Install dependencies
        run: pnpm install
      
      - name: Lint
        run: pnpm lint
      
      - name: Type check
        run: pnpm type-check
      
      - name: Unit tests
        run: pnpm test
      
      - name: Build
        run: pnpm build
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
  
  e2e:
    runs-on: ubuntu-latest
    needs: test
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'
      
      - name: Install dependencies
        run: pnpm install
      
      - name: Install Playwright
        run: pnpm exec playwright install --with-deps
      
      - name: Run E2E tests
        run: pnpm test:e2e
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
```

### 11.3 Vercel設定

```json
// vercel.json
{
  "buildCommand": "pnpm build",
  "devCommand": "pnpm dev",
  "installCommand": "pnpm install",
  "framework": "nextjs",
  "regions": ["hnd1"],  // 東京リージョン
  "env": {
    "OPENAI_API_KEY": "@openai-api-key",
    "ANTHROPIC_API_KEY": "@anthropic-api-key"
  }
}
```

---

## 12. 監視・運用

### 12.1 監視項目

#### 12.1.1 パフォーマンス監視
- ページロード時間
- API レスポンスタイム
- Core Web Vitals (LCP, FID, CLS)

#### 12.1.2 エラー監視
- JavaScript エラー
- API エラー率
- AI API 失敗率

#### 12.1.3 ビジネスメトリクス
- 記事作成完了率
- 各ステップの離脱率
- 平均生成時間
- 再生成率

### 12.2 アラート設定

```typescript
// エラー率が5%を超えたらアラート
if (errorRate > 0.05) {
  sendAlert('High error rate detected');
}

// API レスポンスタイムが10秒を超えたらアラート
if (responseTime > 10000) {
  sendAlert('Slow API response');
}
```

### 12.3 ログ収集（将来）

```
Vercel Logs → Datadog / LogRocket
├── エラーログ
├── パフォーマンスログ
└── ユーザー行動ログ
```

---

## 13. スケーラビリティ

### 13.1 現在の制約（MVP）
- 同時接続数: Vercel Hobby プランの制限内
- ストレージ: ブラウザローカルストレージ（5-10MB）
- AI API: レート制限に依存

### 13.2 スケーリング戦略（将来）

#### 13.2.1 水平スケーリング
```
ユーザー増加時:
├── Vercel Pro プランへアップグレード
├── データベース導入（PostgreSQL + Connection Pooling）
├── Redis キャッシュ導入
└── CDN 活用（静的アセット）
```

#### 13.2.2 AI API コスト最適化
```
コスト削減策:
├── キャッシング（同じ入力の再利用）
├── モデル選択（gpt-3.5-turbo vs gpt-4）
├── プロンプト最適化（トークン削減）
└── バッチ処理（複数リクエストをまとめる）
```

#### 13.2.3 データベース最適化
```
大量データ対応:
├── インデックス最適化
├── パーティショニング（日付ベース）
├── 読み取りレプリカ
└── アーカイブ戦略（古いデータの移動）
```

---

## 14. セキュリティチェックリスト

- [ ] APIキーは環境変数で管理
- [ ] クライアントサイドにAPIキーを露出しない
- [ ] 入力値のサニタイゼーション
- [ ] XSS対策（DOMPurify使用）
- [ ] CSRF対策（Next.js標準機能）
- [ ] レート制限の実装
- [ ] HTTPS強制
- [ ] セキュリティヘッダー設定
- [ ] 依存パッケージの脆弱性チェック（npm audit）
- [ ] 環境変数の適切な管理（.env.local を .gitignore）

---

## 15. 開発ロードマップ

### Phase 1: 環境構築（1週間）
- [ ] Next.js プロジェクト初期化
- [ ] TypeScript 設定
- [ ] Tailwind CSS セットアップ
- [ ] ESLint / Prettier 設定
- [ ] Git リポジトリ作成
- [ ] Vercel 連携

### Phase 2: コア機能実装（3-4週間）
- [ ] プログレスバー・ルーティング
- [ ] テーマ入力画面
- [ ] 見出し生成API + UI
- [ ] 目次生成API + UI（表示のみ）
- [ ] 本文生成API + UI
- [ ] プレビュー画面
- [ ] エクスポート機能

### Phase 3: 編集機能実装（2-3週間）
- [ ] 再生成機能
- [ ] 目次編集（ドラッグ&ドロップ）
- [ ] 本文編集
- [ ] 一時保存機能
- [ ] エラーハンドリング改善

### Phase 4: UX改善（1-2週間）
- [ ] ローディング・アニメーション
- [ ] ストリーミング表示
- [ ] レスポンシブ対応
- [ ] アクセシビリティ改善
- [ ] パフォーマンス最適化

### Phase 5: テスト・デプロイ（1週間）
- [ ] ユニットテスト
- [ ] E2Eテスト
- [ ] 本番デプロイ
- [ ] 監視設定

**合計: 8-11週間**

---

## 16. 技術的な課題と対策

### 16.1 想定される課題

| 課題 | 対策 |
|------|------|
| AI生成の品質のばらつき | プロンプトエンジニアリング、複数候補生成 |
| レスポンスの遅延 | ストリーミング表示、プログレス表示 |
| APIコストの増加 | キャッシング、モデル選択、使用量制限 |
| ブラウザストレージの容量制限 | データ圧縮、古いデータの削除 |
| 複数デバイス間の同期 | 将来的にクラウド保存を実装 |

### 16.2 技術的負債の管理

```
定期的なリファクタリング:
├── コードレビュー（プルリクエスト）
├── 技術的負債の可視化（GitHub Issues）
├── 依存パッケージの更新（Dependabot）
└── パフォーマンス監視
```

---

## 17. ドキュメント管理

### 17.1 必要なドキュメント

```
docs/
├── README.md              # プロジェクト概要
├── SETUP.md               # 環境構築手順
├── API.md                 # API仕様書
├── ARCHITECTURE.md        # アーキテクチャ詳細
├── CONTRIBUTING.md        # 貢献ガイドライン
└── CHANGELOG.md           # 変更履歴
```

### 17.2 コード内ドキュメント

```typescript
/**
 * 見出しを生成するAPI
 * 
 * @param theme - 記事のテーマ
 * @param count - 生成する見出しの数（デフォルト: 5）
 * @returns 見出し候補の配列
 * @throws {ValidationError} テーマが空または500文字超過
 * @throws {AIServiceError} AI API呼び出し失敗
 */
export async function generateHeadlines(
  theme: string,
  count: number = 5
): Promise<Headline[]> {
  // ...
}
```

---

## 18. まとめ

### 18.1 技術選定の要点

| カテゴリ | 選定技術 | 理由 |
|----------|----------|------|
| フロントエンド | Next.js + TypeScript | フルスタック対応、型安全性 |
| 状態管理 | Zustand | シンプル、軽量 |
| スタイリング | Tailwind CSS | 高速開発、カスタマイズ性 |
| AI API | OpenAI / Anthropic | 高品質な生成、両方対応 |
| ホスティング | Vercel | Next.js最適化、簡単デプロイ |
| データ保存（MVP） | LocalStorage | サーバー不要、コスト削減 |

### 18.2 次のステップ

1. **開発環境構築**: Next.js プロジェクト初期化
2. **プロトタイプ作成**: 1つのフローを完成させる
3. **ユーザーテスト**: 早期フィードバック収集
4. **反復改善**: フィードバックを元に改善

---

**文書バージョン**: 1.0  
**作成日**: 2025年12月1日  
**最終更新日**: 2025年12月1日  
**次のアクション**: 開発環境構築、プロトタイプ実装開始

